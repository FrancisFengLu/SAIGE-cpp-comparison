<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SAIGE ScoreNullPack Structure &amp; .arma Binary Output</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: #f5f5f5; padding: 20px; line-height: 1.6;
        }
        .container { max-width: 1800px; margin: 0 auto; background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px; }
        h2 { color: #34495e; margin-top: 30px; margin-bottom: 15px; border-left: 4px solid #3498db; padding-left: 10px; }
        h3 { color: #2980b9; margin-top: 20px; margin-bottom: 10px; }

        .call-tree { font-family: 'Courier New', monospace; font-size: 13px; background: #f8f9fa; padding: 20px; border-radius: 5px; overflow-x: auto; line-height: 1.8; }
        .call-tree .r-func { color: #2980b9; font-weight: bold; }
        .call-tree .cpp-func { color: #27ae60; font-weight: bold; }
        .call-tree .rcpp-func { color: #8e44ad; font-weight: bold; }
        .call-tree .comment { color: #7f8c8d; font-style: italic; }
        .call-tree .line-num { color: #95a5a6; margin-right: 10px; }
        .call-tree .file { color: #e74c3c; }
        .call-tree .var { color: #d35400; }

        .quant-diff {
            background: #fff3e0;
            border: 1px solid #ffb74d;
            border-radius: 3px;
            padding: 1px 6px;
            font-size: 0.85em;
            color: #e65100;
            font-weight: bold;
            font-style: normal;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }
        .shared-badge {
            background: #e8f5e9;
            border: 1px solid #66bb6a;
            border-radius: 3px;
            padding: 1px 6px;
            font-size: 0.85em;
            color: #2e7d32;
            font-weight: bold;
            font-style: normal;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }
        .quant-only {
            background: #fce4ec;
            border: 1px solid #ef9a9a;
            border-radius: 3px;
            padding: 1px 6px;
            font-size: 0.85em;
            color: #c62828;
            font-weight: bold;
            font-style: normal;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }
        .format-badge {
            background: #f3e5f5;
            border: 1px solid #ba68c8;
            border-radius: 3px;
            padding: 1px 6px;
            font-size: 0.85em;
            color: #6a1b9a;
            font-weight: bold;
            font-style: normal;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }

        .legend { display: flex; gap: 20px; margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 5px; flex-wrap: wrap; }
        .legend-item { display: flex; align-items: center; gap: 8px; }
        .legend-box { width: 20px; height: 20px; border-radius: 3px; }
        .legend-r { background: #3498db; }
        .legend-cpp { background: #27ae60; }
        .legend-rcpp { background: #8e44ad; }
        .legend-var { background: #d35400; }
        .legend-quant { background: #ff9800; }
        .legend-shared { background: #4caf50; }
        .legend-format { background: #ab47bc; }

        table { width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 13px; }
        th { background: #3498db; color: white; padding: 10px; text-align: left; position: sticky; top: 0; }
        td { padding: 8px 10px; border-bottom: 1px solid #ddd; vertical-align: top; }
        tr:hover { background: #f9f9f9; }
        .highlight { background: #fff3cd; }

        .diff-table th { background: #e65100; }
        .diff-table td.binary-col { background: #e3f2fd; }
        .diff-table td.quant-col { background: #fff3e0; }

        .format-table th { background: #6a1b9a; }

        code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; font-family: 'Courier New', monospace; font-size: 0.9em; }
        .note { background: #e8f4fd; padding: 15px; border-left: 5px solid #3498db; margin: 20px 0; border-radius: 0 5px 5px 0; }
        .note-quant { background: #fff3e0; padding: 15px; border-left: 5px solid #ff9800; margin: 20px 0; border-radius: 0 5px 5px 0; }
        .note-warn { background: #fff5f5; padding: 15px; border-left: 5px solid #e74c3c; margin: 20px 0; border-radius: 0 5px 5px 0; }
        .note-format { background: #f3e5f5; padding: 15px; border-left: 5px solid #ab47bc; margin: 20px 0; border-radius: 0 5px 5px 0; }

        .side-by-side { display: flex; gap: 20px; margin: 20px 0; }
        .side-by-side .panel { flex: 1; min-width: 0; }
        .panel-binary { border: 2px solid #3498db; border-radius: 8px; padding: 15px; }
        .panel-binary h3 { color: #2980b9; margin-top: 0; }
        .panel-quant { border: 2px solid #ff9800; border-radius: 8px; padding: 15px; }
        .panel-quant h3 { color: #e65100; margin-top: 0; }

        .toc { background: #f8f9fa; padding: 20px; border-radius: 5px; margin: 20px 0; }
        .toc a { color: #2980b9; text-decoration: none; }
        .toc a:hover { text-decoration: underline; }
        .toc ul { list-style: none; padding-left: 20px; }
        .toc > ul { padding-left: 0; }
        .toc li { margin: 5px 0; }

        .struct-field { font-family: 'Courier New', monospace; color: #c0392b; font-weight: bold; }
        .dim-tag { display: inline-block; background: #ecf0f1; border: 1px solid #bdc3c7; border-radius: 3px; padding: 0px 5px; font-size: 0.85em; color: #2c3e50; font-family: 'Courier New', monospace; margin-left: 4px; }
    </style>
</head>
<body>
<div class="container">
    <h1>SAIGE ScoreNullPack Structure &amp; .arma Binary Output</h1>

    <div class="toc">
        <strong>Table of Contents</strong>
        <ul>
            <li>1. <a href="#section1">ScoreNullPack Structure Overview</a></li>
            <li>2. <a href="#section2">ScoreNullPack Fields (Complete Reference)</a></li>
            <li>3. <a href="#section3">Binary vs Quantitative Field Values</a></li>
            <li>4. <a href="#section4">.arma Binary Output Files</a></li>
            <li>5. <a href="#section5">Armadillo Binary Format (arma_binary)</a></li>
            <li>6. <a href="#section6">to_pack() Conversion: float arma to double std::vector</a></li>
            <li>7. <a href="#section7">Step 1 to Step 2 Interface: JSON Manifest + .arma Files</a></li>
            <li>8. <a href="#section8">File Locations</a></li>
        </ul>
    </div>

    <div class="legend">
        <div class="legend-item"><div class="legend-box legend-r"></div><span>R Function</span></div>
        <div class="legend-item"><div class="legend-box legend-cpp"></div><span>C++ Function</span></div>
        <div class="legend-item"><div class="legend-box legend-var"></div><span>Key Variable</span></div>
        <div class="legend-item"><div class="legend-box legend-quant"></div><span><span class="quant-diff">QUANT DIFF</span> Quantitative differs from Binary</span></div>
        <div class="legend-item"><div class="legend-box legend-shared"></div><span><span class="shared-badge">SHARED</span> Same for both</span></div>
        <div class="legend-item"><div class="legend-box legend-format"></div><span><span class="format-badge">FORMAT</span> File format detail</span></div>
    </div>

    <!-- ======================================================================= -->
    <h2 id="section1">1. ScoreNullPack Structure Overview</h2>

    <div class="note">
        <h3>What is ScoreNullPack?</h3>
        <p><code>ScoreNullPack</code> is the C++ structure that packages all outputs from the null model fitting
        (Step 1) into a form consumable by association testing (Step 2). It contains the fitted values,
        residuals, design matrix, and precomputed matrix products needed for efficient score test computation.</p>
        <p style="margin-top: 10px;">In the R SAIGE package, this corresponds to the <code>obj.glmm.fit</code> list object
        returned by <code>fitNULLGLMM()</code>. The C++ standalone serializes these quantities as Armadillo binary
        files (.arma) and a JSON manifest.</p>
    </div>

    <div class="call-tree">
<pre>
<span class="comment"># ===============================================================================</span>
<span class="comment"># ScoreNullPack: packages Step 1 output for Step 2 consumption</span>
<span class="comment"># Defined in: score.hpp / saige_null.hpp</span>
<span class="comment"># ===============================================================================</span>

<span class="cpp-func">struct ScoreNullPack</span> {
    int    <span class="var">n</span>;              <span class="comment">// number of samples (N)</span>
    int    <span class="var">p</span>;              <span class="comment">// number of fixed-effect covariates (including intercept)</span>
    string <span class="var">trait_type</span>;      <span class="comment">// "binary" or "quantitative"</span>

    vector&lt;double&gt; <span class="var">V</span>;      <span class="comment">// [N] working weights for score test</span>
    vector&lt;double&gt; <span class="var">mu</span>;     <span class="comment">// [N] fitted values (fixed effects only)</span>
    vector&lt;double&gt; <span class="var">res</span>;    <span class="comment">// [N] residuals: y - mu</span>
    vector&lt;double&gt; <span class="var">y</span>;      <span class="comment">// [N] phenotype values</span>
    vector&lt;double&gt; <span class="var">S_a</span>;    <span class="comment">// [p] score components: colSums(X .* res)</span>

    vector&lt;double&gt; <span class="var">XV</span>;     <span class="comment">// [p x N] (X .* V)' transposed, stored row-major</span>
    vector&lt;double&gt; <span class="var">XVX</span>;    <span class="comment">// [p x p] X' * V * X</span>
    vector&lt;double&gt; <span class="var">XVX_inv</span>;     <span class="comment">// [p x p] (X'VX)^{-1}</span>
    vector&lt;double&gt; <span class="var">XXVX_inv</span>;    <span class="comment">// [N x p] X * (X'VX)^{-1}</span>
    vector&lt;double&gt; <span class="var">XVX_inv_XV</span>;  <span class="comment">// [N x p] (X * (X'VX)^{-1}) .* V  -- note: see derivation below</span>
    vector&lt;double&gt; <span class="var">X</span>;      <span class="comment">// [N x p] design matrix</span>
};
</pre>
    </div>

    <!-- ======================================================================= -->
    <h2 id="section2">2. ScoreNullPack Fields (Complete Reference)</h2>

    <table>
        <thead>
            <tr>
                <th>Field</th>
                <th>Dimensions</th>
                <th>Storage Type</th>
                <th>Description</th>
                <th>Formula / Source</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><span class="struct-field">n</span></td>
                <td><span class="dim-tag">1</span></td>
                <td>int</td>
                <td>Number of samples</td>
                <td>From input phenotype file</td>
            </tr>
            <tr class="highlight">
                <td><span class="struct-field">p</span></td>
                <td><span class="dim-tag">1</span></td>
                <td>int</td>
                <td>Number of covariates (including intercept)</td>
                <td>ncol(X)</td>
            </tr>
            <tr>
                <td><span class="struct-field">trait_type</span></td>
                <td><span class="dim-tag">1</span></td>
                <td>string</td>
                <td>Trait type identifier</td>
                <td>"binary" or "quantitative"</td>
            </tr>
            <tr class="highlight">
                <td><span class="struct-field">V</span></td>
                <td><span class="dim-tag">N</span></td>
                <td>vector&lt;double&gt;</td>
                <td>Working weights for score test variance</td>
                <td>Binary: mu*(1-mu)<br>Quant: 1/tau[0] (scalar broadcast to N)</td>
            </tr>
            <tr>
                <td><span class="struct-field">mu</span></td>
                <td><span class="dim-tag">N</span></td>
                <td>vector&lt;double&gt;</td>
                <td>Fitted values from fixed effects only</td>
                <td>Binary: expit(X*alpha + offset)<br>Quant: X*alpha + offset</td>
            </tr>
            <tr class="highlight">
                <td><span class="struct-field">res</span></td>
                <td><span class="dim-tag">N</span></td>
                <td>vector&lt;double&gt;</td>
                <td>Residuals</td>
                <td>y - mu</td>
            </tr>
            <tr>
                <td><span class="struct-field">y</span></td>
                <td><span class="dim-tag">N</span></td>
                <td>vector&lt;double&gt;</td>
                <td>Phenotype values</td>
                <td>From input phenotype file</td>
            </tr>
            <tr class="highlight">
                <td><span class="struct-field">S_a</span></td>
                <td><span class="dim-tag">p</span></td>
                <td>vector&lt;double&gt;</td>
                <td>Score vector components</td>
                <td>colSums(X .* res) = X' * res</td>
            </tr>
            <tr>
                <td><span class="struct-field">XV</span></td>
                <td><span class="dim-tag">p x N</span></td>
                <td>vector&lt;double&gt;</td>
                <td>(X .* V)' transposed</td>
                <td>(X * diag(V))' = diag(V) * X' (row-major flattened)</td>
            </tr>
            <tr class="highlight">
                <td><span class="struct-field">XVX</span></td>
                <td><span class="dim-tag">p x p</span></td>
                <td>vector&lt;double&gt;</td>
                <td>X'VX information matrix</td>
                <td>X' * diag(V) * X</td>
            </tr>
            <tr>
                <td><span class="struct-field">XVX_inv</span></td>
                <td><span class="dim-tag">p x p</span></td>
                <td>vector&lt;double&gt;</td>
                <td>Inverse of X'VX</td>
                <td>(X' * diag(V) * X)^{-1}</td>
            </tr>
            <tr class="highlight">
                <td><span class="struct-field">XXVX_inv</span></td>
                <td><span class="dim-tag">N x p</span></td>
                <td>vector&lt;double&gt;</td>
                <td>X times inverse information</td>
                <td>X * (X'VX)^{-1}</td>
            </tr>
            <tr>
                <td><span class="struct-field">XVX_inv_XV</span></td>
                <td><span class="dim-tag">N x p</span></td>
                <td>vector&lt;double&gt;</td>
                <td>Combined projection matrix factor</td>
                <td>(X * (X'VX)^{-1}) .* V &mdash; elementwise multiply of XXVX_inv with V</td>
            </tr>
            <tr class="highlight">
                <td><span class="struct-field">X</span></td>
                <td><span class="dim-tag">N x p</span></td>
                <td>vector&lt;double&gt;</td>
                <td>Design matrix (intercept + covariates)</td>
                <td>From input covariate data</td>
            </tr>
        </tbody>
    </table>

    <div class="note">
        <h3>Dimension Key</h3>
        <p><code>N</code> = number of samples, <code>p</code> = number of covariates (including intercept column).
        For a model with 2 covariates (e.g., x1 and x2), <code>p = 3</code> (intercept + x1 + x2).</p>
        <p style="margin-top: 10px;">All matrix fields are stored as flattened <code>std::vector&lt;double&gt;</code> in
        <strong>row-major order</strong> after conversion from Armadillo's column-major format.</p>
    </div>

    <!-- ======================================================================= -->
    <h2 id="section3">3. Binary vs Quantitative Field Values</h2>

    <table class="diff-table">
        <thead>
            <tr>
                <th>Field</th>
                <th>Binary Trait</th>
                <th>Quantitative Trait</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>trait_type</strong></td>
                <td class="binary-col"><code>"binary"</code></td>
                <td class="quant-col"><code>"quantitative"</code></td>
            </tr>
            <tr>
                <td><strong>V</strong></td>
                <td class="binary-col"><code>mu * (1 - mu)</code><br>Varies per sample (logistic variance)</td>
                <td class="quant-col"><code>1 / tau[0]</code><br>Constant scalar broadcast to all N entries</td>
            </tr>
            <tr>
                <td><strong>mu</strong></td>
                <td class="binary-col"><code>expit(X*alpha + offset)</code><br>Values in (0, 1)</td>
                <td class="quant-col"><code>X*alpha + offset</code><br>Real-valued (identity link)</td>
            </tr>
            <tr>
                <td><strong>res</strong></td>
                <td class="binary-col"><code>y - expit(X*alpha)</code><br>Values in (-1, 1)</td>
                <td class="quant-col"><code>y - X*alpha</code><br>Real-valued residuals</td>
            </tr>
            <tr>
                <td><strong>XV</strong></td>
                <td class="binary-col"><code>(X .* mu*(1-mu))'</code><br>Sample-varying weights</td>
                <td class="quant-col"><code>(X .* (1/tau[0]))'</code><br>= <code>X' / tau[0]</code> (uniform scaling)</td>
            </tr>
            <tr>
                <td><strong>XVX</strong></td>
                <td class="binary-col"><code>X' * diag(mu*(1-mu)) * X</code></td>
                <td class="quant-col"><code>X' * X / tau[0]</code></td>
            </tr>
            <tr>
                <td><strong>S_a, XVX_inv, XXVX_inv, XVX_inv_XV, X, y</strong></td>
                <td class="binary-col" colspan="2" style="text-align: center; background: #e8f5e9;"><span class="shared-badge">SHARED</span> -- same formula, different V plugged in</td>
            </tr>
        </tbody>
    </table>

    <div class="note-quant">
        <h3>Why V = 1/tau[0] for Quantitative?</h3>
        <p>For the quantitative trait model, <code>Sigma = tau[0]*I + tau[1]*K</code>. The score test in Step 2
        uses <code>V</code> as the "working variance" under the null (no genetic effect). Under the null with
        only fixed effects, the residual variance is <code>tau[0]</code>, so the weight (inverse variance) is
        <code>1/tau[0]</code>. This is a constant for all samples, unlike the binary case where
        <code>mu*(1-mu)</code> varies per sample.</p>
    </div>

    <!-- ======================================================================= -->
    <h2 id="section4">4. .arma Binary Output Files</h2>

    <p>Step 1 serializes each ScoreNullPack field as a separate Armadillo binary file. There are 11 files total.</p>

    <table class="format-table">
        <thead>
            <tr>
                <th>#</th>
                <th>Filename</th>
                <th>Armadillo Type</th>
                <th>Dimensions</th>
                <th>ScoreNullPack Field</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td><code>mu.arma</code></td>
                <td>arma::fvec</td>
                <td>N</td>
                <td><span class="struct-field">mu</span></td>
            </tr>
            <tr class="highlight">
                <td>2</td>
                <td><code>res.arma</code></td>
                <td>arma::fvec</td>
                <td>N</td>
                <td><span class="struct-field">res</span></td>
            </tr>
            <tr>
                <td>3</td>
                <td><code>y.arma</code></td>
                <td>arma::fvec</td>
                <td>N</td>
                <td><span class="struct-field">y</span></td>
            </tr>
            <tr class="highlight">
                <td>4</td>
                <td><code>V.arma</code></td>
                <td>arma::fvec</td>
                <td>N</td>
                <td><span class="struct-field">V</span></td>
            </tr>
            <tr>
                <td>5</td>
                <td><code>S_a.arma</code></td>
                <td>arma::fvec</td>
                <td>p</td>
                <td><span class="struct-field">S_a</span></td>
            </tr>
            <tr class="highlight">
                <td>6</td>
                <td><code>X.arma</code></td>
                <td>arma::fmat</td>
                <td>N x p</td>
                <td><span class="struct-field">X</span></td>
            </tr>
            <tr>
                <td>7</td>
                <td><code>XV.arma</code></td>
                <td>arma::fmat</td>
                <td>p x N</td>
                <td><span class="struct-field">XV</span></td>
            </tr>
            <tr class="highlight">
                <td>8</td>
                <td><code>XVX.arma</code></td>
                <td>arma::fmat</td>
                <td>p x p</td>
                <td><span class="struct-field">XVX</span></td>
            </tr>
            <tr>
                <td>9</td>
                <td><code>XVX_inv.arma</code></td>
                <td>arma::fmat</td>
                <td>p x p</td>
                <td><span class="struct-field">XVX_inv</span></td>
            </tr>
            <tr class="highlight">
                <td>10</td>
                <td><code>XXVX_inv.arma</code></td>
                <td>arma::fmat</td>
                <td>N x p</td>
                <td><span class="struct-field">XXVX_inv</span></td>
            </tr>
            <tr>
                <td>11</td>
                <td><code>XVX_inv_XV.arma</code></td>
                <td>arma::fmat</td>
                <td>N x p</td>
                <td><span class="struct-field">XVX_inv_XV</span></td>
            </tr>
        </tbody>
    </table>

    <div class="note-warn">
        <h3>Important: float (arma::fvec/fmat) Not double</h3>
        <p>All .arma files use <strong>single-precision float (32-bit)</strong> types: <code>arma::fvec</code> for vectors
        and <code>arma::fmat</code> for matrices. This matches SAIGE's internal computation precision. The
        <code>to_pack()</code> conversion function promotes these to <code>double</code> when loading into
        ScoreNullPack (see Section 6).</p>
    </div>

    <!-- ======================================================================= -->
    <h2 id="section5">5. Armadillo Binary Format (arma_binary)</h2>

    <div class="note-format">
        <h3>arma_binary File Layout</h3>
        <p>Armadillo's <code>arma_binary</code> format is a simple, portable binary format for matrices and vectors.
        Files consist of a text header followed by raw binary data.</p>
    </div>

    <h3>5a. Vector Format (arma::fvec)</h3>

    <div class="call-tree">
<pre>
<span class="comment"># ===============================================================================</span>
<span class="comment"># arma::fvec arma_binary layout</span>
<span class="comment"># ===============================================================================</span>

<strong>Line 1 (text):</strong>  ARMA_MAT_BIN_FN008             <span class="comment"># magic string identifying format</span>
<strong>Line 2 (text):</strong>  N 1                             <span class="comment"># rows cols (vector = N rows, 1 col)</span>
<strong>Data (binary):</strong>  N x sizeof(float) bytes          <span class="comment"># raw float values, little-endian</span>

<span class="comment"># Example: mu.arma for N=1000 samples</span>
<span class="comment"># Line 1: "ARMA_MAT_BIN_FN008\n"         (text)</span>
<span class="comment"># Line 2: "1000 1\n"                      (text)</span>
<span class="comment"># Bytes:  1000 * 4 = 4000 bytes           (raw float32 data)</span>

<span class="comment"># Total file size: ~18 + ~7 + 4000 = ~4025 bytes</span>
</pre>
    </div>

    <h3>5b. Matrix Format (arma::fmat)</h3>

    <div class="call-tree">
<pre>
<span class="comment"># ===============================================================================</span>
<span class="comment"># arma::fmat arma_binary layout</span>
<span class="comment"># ===============================================================================</span>

<strong>Line 1 (text):</strong>  ARMA_MAT_BIN_FN008             <span class="comment"># same magic string</span>
<strong>Line 2 (text):</strong>  rows cols                       <span class="comment"># matrix dimensions</span>
<strong>Data (binary):</strong>  rows * cols * sizeof(float)      <span class="comment"># raw float values, COLUMN-MAJOR order</span>

<span class="comment"># Example: X.arma for N=1000 samples, p=3 covariates</span>
<span class="comment"># Line 1: "ARMA_MAT_BIN_FN008\n"         (text)</span>
<span class="comment"># Line 2: "1000 3\n"                      (text)</span>
<span class="comment"># Bytes:  1000 * 3 * 4 = 12000 bytes     (raw float32 data)</span>
<span class="comment">#</span>
<span class="comment"># IMPORTANT: Armadillo stores matrices in COLUMN-MAJOR order!</span>
<span class="comment"># Data layout: col0[0..999], col1[0..999], col2[0..999]</span>
<span class="comment"># NOT row-major: row0[0..2], row1[0..2], ...</span>
</pre>
    </div>

    <h3>5c. How to Load</h3>

    <div class="call-tree">
<pre>
<span class="comment"># ===============================================================================</span>
<span class="comment"># Loading .arma files in C++ with Armadillo</span>
<span class="comment"># ===============================================================================</span>

<span class="comment">// Load a vector</span>
<span class="cpp-func">arma::fvec</span> mu_vec;
mu_vec.<span class="cpp-func">load</span>(path + "/mu.arma", <span class="var">arma::arma_binary</span>);

<span class="comment">// Load a matrix</span>
<span class="cpp-func">arma::fmat</span> X_mat;
X_mat.<span class="cpp-func">load</span>(path + "/X.arma", <span class="var">arma::arma_binary</span>);

<span class="comment">// Verify dimensions after loading</span>
assert(mu_vec.n_elem == N);
assert(X_mat.n_rows == N && X_mat.n_cols == p);

<span class="comment"># ===============================================================================</span>
<span class="comment"># Saving .arma files (done by Step 1 after fitting)</span>
<span class="comment"># ===============================================================================</span>

<span class="comment">// Save a vector</span>
<span class="cpp-func">arma::fvec</span> mu_vec = ...;
mu_vec.<span class="cpp-func">save</span>(path + "/mu.arma", <span class="var">arma::arma_binary</span>);

<span class="comment">// Save a matrix</span>
<span class="cpp-func">arma::fmat</span> X_mat = ...;
X_mat.<span class="cpp-func">save</span>(path + "/X.arma", <span class="var">arma::arma_binary</span>);
</pre>
    </div>

    <!-- ======================================================================= -->
    <h2 id="section6">6. to_pack() Conversion: float arma to double std::vector</h2>

    <div class="note">
        <h3>Purpose of to_pack()</h3>
        <p>The <code>to_pack()</code> function converts Armadillo's <code>float</code> (32-bit) vectors and matrices
        into the ScoreNullPack's <code>double</code> (64-bit) <code>std::vector</code> format. This involves two
        transformations: (1) type promotion from float to double, and (2) for matrices, reordering from
        Armadillo's column-major layout to row-major flattened std::vector.</p>
    </div>

    <div class="call-tree">
<pre>
<span class="comment"># ===============================================================================</span>
<span class="comment"># to_pack() conversion logic</span>
<span class="comment"># Defined in: score.cpp / null_model_engine.cpp</span>
<span class="comment"># ===============================================================================</span>

<span class="cpp-func">ScoreNullPack to_pack</span>(...) {

    ScoreNullPack pack;

    <span class="comment">// 1. VECTOR CONVERSION: float arma::fvec -> double std::vector</span>
    <span class="comment">//    Simply iterate and cast each element</span>
    <span class="comment">//</span>
    <span class="comment">//    arma::fvec mu_arma;  // loaded from mu.arma (float32)</span>
    <span class="comment">//    pack.mu.resize(N);</span>
    <span class="comment">//    for (int i = 0; i < N; i++)</span>
    <span class="comment">//        pack.mu[i] = static_cast&lt;double&gt;(mu_arma[i]);</span>

    <span class="comment">// 2. MATRIX CONVERSION: float arma::fmat (col-major) -> double std::vector (row-major)</span>
    <span class="comment">//    Armadillo stores matrices in COLUMN-major order.</span>
    <span class="comment">//    ScoreNullPack uses ROW-major flattening for std::vector.</span>
    <span class="comment">//</span>
    <span class="comment">//    arma::fmat X_arma;  // loaded from X.arma, shape [N x p], col-major</span>
    <span class="comment">//    pack.X.resize(N * p);</span>
    <span class="comment">//    for (int i = 0; i < N; i++)</span>
    <span class="comment">//        for (int j = 0; j < p; j++)</span>
    <span class="comment">//            pack.X[i * p + j] = static_cast&lt;double&gt;(X_arma(i, j));</span>
    <span class="comment">//</span>
    <span class="comment">//    Note: X_arma(i,j) accesses col-major memory at offset [j*N + i]</span>
    <span class="comment">//          pack.X[i*p + j] stores in row-major at offset [i*p + j]</span>

    return pack;
}
</pre>
    </div>

    <h3>6a. Memory Layout Comparison</h3>

    <div class="side-by-side">
        <div class="panel panel-binary">
            <h3>Armadillo (Column-Major)</h3>
            <div class="call-tree" style="font-size: 12px;">
<pre>
<span class="comment"># arma::fmat X, shape 4x3 (4 rows, 3 cols)</span>
<span class="comment"># Memory layout:</span>

offset 0:  X(0,0)  <span class="comment"># col 0</span>
offset 1:  X(1,0)
offset 2:  X(2,0)
offset 3:  X(3,0)
offset 4:  X(0,1)  <span class="comment"># col 1</span>
offset 5:  X(1,1)
offset 6:  X(2,1)
offset 7:  X(3,1)
offset 8:  X(0,2)  <span class="comment"># col 2</span>
offset 9:  X(1,2)
offset 10: X(2,2)
offset 11: X(3,2)

<span class="comment"># Access: X(i,j) = memory[j*nrows + i]</span>
<span class="comment"># This is Fortran/LAPACK convention</span>
</pre>
            </div>
        </div>

        <div class="panel panel-quant">
            <h3>std::vector (Row-Major Flattened)</h3>
            <div class="call-tree" style="font-size: 12px;">
<pre>
<span class="comment"># pack.X, size 4*3=12, row-major</span>
<span class="comment"># Memory layout:</span>

offset 0:  X(0,0)  <span class="comment"># row 0</span>
offset 1:  X(0,1)
offset 2:  X(0,2)
offset 3:  X(1,0)  <span class="comment"># row 1</span>
offset 4:  X(1,1)
offset 5:  X(1,2)
offset 6:  X(2,0)  <span class="comment"># row 2</span>
offset 7:  X(2,1)
offset 8:  X(2,2)
offset 9:  X(3,0)  <span class="comment"># row 3</span>
offset 10: X(3,1)
offset 11: X(3,2)

<span class="comment"># Access: X(i,j) = memory[i*ncols + j]</span>
<span class="comment"># This is C/C++ convention</span>
</pre>
            </div>
        </div>
    </div>

    <!-- ======================================================================= -->
    <h2 id="section7">7. Step 1 to Step 2 Interface: JSON Manifest + .arma Files</h2>

    <div class="note">
        <h3>Interface Overview</h3>
        <p>Step 1 (null model fitting) outputs a directory containing a JSON manifest file and 11 .arma binary files.
        Step 2 (association testing) reads this directory to reconstruct the ScoreNullPack structure.</p>
    </div>

    <div class="call-tree">
<pre>
<span class="comment"># ===============================================================================</span>
<span class="comment"># Step 1 Output Directory Structure</span>
<span class="comment"># ===============================================================================</span>

output_dir/
├── <strong>manifest.json</strong>          <span class="comment"># metadata: n, p, trait_type, tau, variance_ratio, file paths</span>
├── mu.arma                 <span class="comment"># arma::fvec [N]</span>
├── res.arma                <span class="comment"># arma::fvec [N]</span>
├── y.arma                  <span class="comment"># arma::fvec [N]</span>
├── V.arma                  <span class="comment"># arma::fvec [N]</span>
├── S_a.arma                <span class="comment"># arma::fvec [p]</span>
├── X.arma                  <span class="comment"># arma::fmat [N x p]</span>
├── XV.arma                 <span class="comment"># arma::fmat [p x N]</span>
├── XVX.arma                <span class="comment"># arma::fmat [p x p]</span>
├── XVX_inv.arma            <span class="comment"># arma::fmat [p x p]</span>
├── XXVX_inv.arma           <span class="comment"># arma::fmat [N x p]</span>
└── XVX_inv_XV.arma         <span class="comment"># arma::fmat [N x p]</span>
</pre>
    </div>

    <h3>7a. JSON Manifest</h3>

    <div class="call-tree">
<pre>
<span class="comment"># ===============================================================================</span>
<span class="comment"># manifest.json example</span>
<span class="comment"># ===============================================================================</span>

{
    "n": 1000,
    "p": 3,
    "trait_type": "binary",
    "tau": [1.0, 0.2901],
    "variance_ratio": 0.8234567,
    "files": {
        "mu":          "mu.arma",
        "res":         "res.arma",
        "y":           "y.arma",
        "V":           "V.arma",
        "S_a":         "S_a.arma",
        "X":           "X.arma",
        "XV":          "XV.arma",
        "XVX":         "XVX.arma",
        "XVX_inv":     "XVX_inv.arma",
        "XXVX_inv":    "XXVX_inv.arma",
        "XVX_inv_XV":  "XVX_inv_XV.arma"
    }
}
</pre>
    </div>

    <h3>7b. Loading Sequence in Step 2</h3>

    <div class="call-tree">
<pre>
<span class="comment"># ===============================================================================</span>
<span class="comment"># Step 2 loads the null model output and constructs ScoreNullPack</span>
<span class="comment"># File: null_model_engine.cpp / score.cpp</span>
<span class="comment"># ===============================================================================</span>

<span class="cpp-func">load_null_model</span>(output_dir) {
    │
    ├── <span class="comment">// 1. Parse manifest.json</span>
    │   ├── Read n, p, trait_type
    │   ├── Read tau[0], tau[1]
    │   └── Read variance_ratio
    │
    ├── <span class="comment">// 2. Load all .arma files into Armadillo objects</span>
    │   ├── arma::fvec mu_arma;    mu_arma.load(dir + "/mu.arma", arma::arma_binary);
    │   ├── arma::fvec res_arma;   res_arma.load(dir + "/res.arma", arma::arma_binary);
    │   ├── arma::fvec y_arma;     y_arma.load(dir + "/y.arma", arma::arma_binary);
    │   ├── arma::fvec V_arma;     V_arma.load(dir + "/V.arma", arma::arma_binary);
    │   ├── arma::fvec S_a_arma;   S_a_arma.load(dir + "/S_a.arma", arma::arma_binary);
    │   ├── arma::fmat X_arma;     X_arma.load(dir + "/X.arma", arma::arma_binary);
    │   ├── arma::fmat XV_arma;    XV_arma.load(dir + "/XV.arma", arma::arma_binary);
    │   ├── arma::fmat XVX_arma;   XVX_arma.load(dir + "/XVX.arma", arma::arma_binary);
    │   ├── arma::fmat XVXi_arma;  XVXi_arma.load(dir + "/XVX_inv.arma", arma::arma_binary);
    │   ├── arma::fmat XXVXi_arma; XXVXi_arma.load(dir + "/XXVX_inv.arma", arma::arma_binary);
    │   └── arma::fmat XViXV_arma; XViXV_arma.load(dir + "/XVX_inv_XV.arma", arma::arma_binary);
    │
    ├── <span class="comment">// 3. Validate dimensions</span>
    │   ├── assert(mu_arma.n_elem == n)
    │   ├── assert(X_arma.n_rows == n && X_arma.n_cols == p)
    │   └── ... etc ...
    │
    └── <span class="comment">// 4. Convert to ScoreNullPack via to_pack()</span>
        └── ScoreNullPack pack = <span class="cpp-func">to_pack</span>(n, p, trait_type,
                mu_arma, res_arma, y_arma, V_arma, S_a_arma,
                X_arma, XV_arma, XVX_arma, XVXi_arma,
                XXVXi_arma, XViXV_arma);
}
</pre>
    </div>

    <!-- ======================================================================= -->
    <h2 id="section8">8. File Locations</h2>

    <table>
        <thead>
            <tr>
                <th>Component</th>
                <th>File</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr class="highlight">
                <td><strong>ScoreNullPack definition</strong></td>
                <td><code>score.hpp</code> / <code>saige_null.hpp</code></td>
                <td>Struct definition with all fields</td>
            </tr>
            <tr>
                <td><strong>ScoreNullPack population</strong></td>
                <td><code>score.cpp</code></td>
                <td>Code that fills the pack from fitted model</td>
            </tr>
            <tr class="highlight">
                <td><strong>to_pack() conversion</strong></td>
                <td><code>score.cpp</code> / <code>null_model_engine.cpp</code></td>
                <td>Float-to-double, col-major to row-major</td>
            </tr>
            <tr>
                <td><strong>.arma file saving</strong></td>
                <td><code>null_model_engine.cpp</code></td>
                <td>Armadillo save() calls after Step 1</td>
            </tr>
            <tr class="highlight">
                <td><strong>.arma file loading</strong></td>
                <td><code>null_model_engine.cpp</code></td>
                <td>Armadillo load() calls at Step 2 start</td>
            </tr>
            <tr>
                <td><strong>JSON manifest write</strong></td>
                <td><code>null_model_engine.cpp</code></td>
                <td>nlohmann/json or manual JSON output</td>
            </tr>
            <tr class="highlight">
                <td><strong>JSON manifest read</strong></td>
                <td><code>null_model_engine.cpp</code></td>
                <td>Parsing n, p, trait_type, tau, etc.</td>
            </tr>
            <tr>
                <td><strong>R equivalent (obj.glmm.fit)</strong></td>
                <td><code>SAIGE_fitGLMM_fast.R</code></td>
                <td>R list object containing same quantities</td>
            </tr>
        </tbody>
    </table>

    <div class="note">
        <h3>R Equivalent Fields</h3>
        <p>The R package stores the same information in the <code>obj.glmm.fit</code> list returned by
        <code>fitNULLGLMM()</code>. The mapping is:</p>
        <table style="width: auto; margin-top: 10px;">
            <thead>
                <tr>
                    <th>ScoreNullPack (C++)</th>
                    <th>obj.glmm.fit (R)</th>
                </tr>
            </thead>
            <tbody>
                <tr><td><code>mu</code></td><td><code>$fitted.values</code></td></tr>
                <tr><td><code>res</code></td><td><code>$residuals</code></td></tr>
                <tr><td><code>y</code></td><td><code>$y</code></td></tr>
                <tr><td><code>V</code></td><td><code>$W</code> (binary) or <code>1/tau[1]</code> (quant)</td></tr>
                <tr><td><code>X</code></td><td><code>$X1</code> (after QR back-transform)</td></tr>
                <tr><td><code>XV</code></td><td><code>$XV</code></td></tr>
                <tr><td><code>XVX</code></td><td><code>$XVX</code></td></tr>
                <tr><td><code>XVX_inv</code></td><td><code>$XVX_inv</code></td></tr>
                <tr><td><code>XXVX_inv</code></td><td><code>$XXVX_inv</code></td></tr>
                <tr><td><code>S_a</code></td><td><code>$S_a</code></td></tr>
            </tbody>
        </table>
    </div>

    <hr style="margin: 40px 0;">
    <p style="color: #888; font-size: 12px;">
        Generated: February 10, 2026<br>
        ScoreNullPack structure and .arma binary output documentation for SAIGE R-to-C++ comparison project<br>
        Output directory: <code>/Users/francis/Desktop/Zhou_lab/SAIGE_gene_pixi/Jan_30_comparison/</code>
    </p>
</div>
</body>
</html>
